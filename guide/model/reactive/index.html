<!doctype html> <html> <head> <title>Reactive Form - 模型驱动、可扩展的表单引擎</title> <meta charset=UTF-8> <meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"> <meta name=renderer content=webkit> <meta http-equiv=X-UA-Compatible content="IE=Edge,chrome=1"> <meta name=apple-mobile-web-app-capable content=yes> <meta name=apple-mobile-web-app-status-bar-style content=black-translucent> <meta name=apple-mobile-web-app-title content=ReactiveForm> <meta name=mobile-web-app-capable content=ReactiveForm> <meta name=application-name content=ReactiveForm> <meta content="telephone=no" name=format-detection> <meta name=msapplication-tap-highlight content=no> <meta name=author content=""> <meta name=keywords content=""> <meta name=description content=""> <link rel="shortcut icon" href="/favicon.ico"> <script src="/assets/javascripts/luda-degradation.min-de40bf23.js"></script> <script src="/assets/javascripts/turbo.es2017-umd.min-6c3e5b73.js" data-turbo-track=reload></script> <link href="/assets/stylesheets/luda-default.min-d9508530.css" rel=stylesheet data-turbo-track=reload /> <link href="/assets/stylesheets/rouge-ebba3ab6.css" rel=stylesheet data-turbo-track=reload /> <link href="/assets/stylesheets/site-b4ec337b.css" rel=stylesheet data-turbo-track=reload /> <script src="/assets/javascripts/luda.min-10857b5a.js" data-turbo-track=reload></script> </head> <body id=""> <div class=grid-edge> <aside class="nav-aside col-12 col-3-m bc-light sd-low"> <a href="/" class=nav-logo> <picture class=d-block> <source srcset="/assets/images/logo-f19b9c85.svg" media="(min-width: 768px)"> <img src="/assets/images/logo_full-dcdab38b.svg" alt="rcfm logo" width=""/> </picture> </a> <button class="nav-open btn btn-ico btn-text-dark" data-toggle-for=aside-menu> <i class="ico ico-menu"></i> </button> <div class="nav-menu pb-large" data-toggle-target=aside-menu> <button class="nav-close btn btn-ico btn-text-dark" data-toggleable> <i class="ico ico-cross"></i> </button> <div class="nav-items mx-medium"> <p class="nav-items-title px-small mb-tiny fw-bold c-dark">开始</p> <a href="/guide/general/situations/" title="适用场景" class="btn btn-text-dark btn-small mt-tiny rounded ">适用场景</a> <a href="/guide/general/platforms/" title="兼容性" class="btn btn-text-dark btn-small mt-tiny rounded ">兼容性</a> <a href="/guide/general/installation/" title="安装方式" class="btn btn-text-dark btn-small mt-tiny rounded ">安装方式</a> <a href="/guide/general/get_started/" title="入门示例" class="btn btn-text-dark btn-small mt-tiny rounded ">入门示例</a> </div> <div class="nav-items mx-medium"> <p class="nav-items-title px-small mb-tiny fw-bold c-dark">模型</p> <a href="/guide/model/introduction/" title="概述" class="btn btn-text-dark btn-small mt-tiny rounded ">概述</a> <a href="/guide/model/reactive/" title=Reactive class="btn btn-text-dark btn-small mt-tiny rounded btn-active">Reactive</a> <a href="/guide/model/reactive_customization/" title="构建引擎" class="btn btn-text-dark btn-small mt-tiny rounded ">构建引擎</a> <a href="/guide/model/form/" title="内置引擎" class="btn btn-text-dark btn-small mt-tiny rounded ">内置引擎</a> <a href="/guide/model/form_customization/" title="扩展内置引擎" class="btn btn-text-dark btn-small mt-tiny rounded ">扩展内置引擎</a> <a href="/guide/model/i18n/" title="国际化" class="btn btn-text-dark btn-small mt-tiny rounded ">国际化</a> </div> <div class="nav-items mx-medium"> <p class="nav-items-title px-small mb-tiny fw-bold c-dark">组件</p> <a href="/guide/ui/introduction/" title="概述" class="btn btn-text-dark btn-small mt-tiny rounded ">概述</a> <a href="/guide/ui/subscription/" title="订阅成员状态" class="btn btn-text-dark btn-small mt-tiny rounded ">订阅成员状态</a> <a href="/guide/ui/installation/" title="注册成员组件" class="btn btn-text-dark btn-small mt-tiny rounded ">注册成员组件</a> <a href="/guide/ui/form/" title="内置引擎组件" class="btn btn-text-dark btn-small mt-tiny rounded ">内置引擎组件</a> </div> <div class="nav-items mx-medium"> <p class="nav-items-title px-small mb-tiny fw-bold c-dark">其它</p> <a href="/guide/others/faq/" title=FAQ class="btn btn-text-dark btn-small mt-tiny rounded ">FAQ</a> <a href="/guide/others/summary/" title="写在最后" class="btn btn-text-dark btn-small mt-tiny rounded ">写在最后</a> </div> </div> </aside> <div class=col-auto> <article class="docs article p-medium p-large-m "> <h1 id=reactive>Reactive</h1> <p>无论构建什么类型的表单引擎，我们需要的基础能力往往类似， 如数据合规性的校验能力，条件分支的解析能力等。</p> <p>Reactive 对构建表单引擎所需的各种能力进行了聚合，提供了多样的扩展方式， 来帮助开发者高效率地构建引擎。简单的说，<strong>Reactive 是一个可被扩展的引擎核心。</strong></p> <p>本章着重介绍 Reactive 的重要概念、原理，以及核心实现， 建议想要深入理解 Reacitve 或有基于 Reactive 深度定制需求的读者阅读。</p> <h2 id="实例化过程">实例化过程</h2> <p>Reactive 对各种引擎能力的组合发生在实例化过程中， <strong>Reactive 实例本质上是组合了其它模型的 <a href="/api/context/">Context</a> 实例。</strong> 为了让读者能清楚地了解这个过程，我们在下面的流程图中，以伪代码展示了各个节点的核心实现。</p> <figure class="media w-100" style="max-width: 521px"> <picture class=media-content style="padding-top: 389.8273%"> <img src="/assets/images/reactive_instantiation-d9b9884d.png" alt="实例化流程图" width=1042 height=4062 /> </picture> </figure> <h2 id="关于成员">关于成员</h2> <p>Reactive 在实例化后会形成一个上下文环境，在这个环境中可以存在不同类型的成员。 所谓“不同类型的成员”指的是上下文环境中属性和行为存在差异的基本单元。 Reactive 为每个成员开辟独立的存储空间以存储其状态，<strong>成员状态包括属性设定值、属性当前值，以及错误信息。</strong></p> <p><strong>属性的设定值和当前值在无成员间关联时是相同的，但在有成员间关联时是不同的。</strong> 比如，<code>memberB</code> 的 <code>age</code> 由 <code>memberA</code> 的 <code>age * 3</code> 动态计算得到， 这种情况下，<code>memberB</code> 的 <code>age</code> 设定值，存储的是描述依赖关系和计算逻辑的表达式 <code>{"multiple": ["&lt;&lt; memberA.age &gt;&gt;", 3]}</code>， 而当前值存储的则是，根据 <code>memberA</code> 的 <code>age</code> 变化而动态计算得到的结果。</p> <p>为了处理成员间的依赖追踪和属性联动，以及其它必要的干预，Reactive 在实例化时“注入了必备钩子函数”， 这些钩子函数起到的作用包括：</p> <h3 id="预设并冻结成员-type">预设并冻结成员 type</h3> <p>当成员被创建后，优先设定其 <code>type</code> 属性，如果创建时，未定义成员 <code>type</code>，默认为 <code>default</code>。 <strong>成员的 <code>type</code> 是区分成员类型的标识，被设定后，不接受更新，且不接受被设定为 DSL。</strong></p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/1" src="https://codepen.io/rcfm/embed/jOapqYe?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/jOapqYe"> model/reactive/1</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="预设并校验成员-name">预设并校验成员 name</h3> <p>当成员被创建后，优先设定其 <code>name</code> 属性， 如果创建时，未定义成员 <code>name</code>，默认为其 <code>id</code>， 当 <code>name</code> 被更新时，执行同辈成员间 <code>name</code> 唯一性校验。 <strong>成员的 <code>name</code> 在 DSL 插值符引用路径中是同辈成员间的唯一性标识，不接受被设定为 DSL。</strong></p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/2" src="https://codepen.io/rcfm/embed/YzERBeb?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/YzERBeb"> model/reactive/2</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="解析成员属性-dsl">解析成员属性 DSL</h3> <p>根据成员属性的设定值是否包含 DSL，自动建立/解除成员间的关联关系，动态解析 DSL 并更新该属性的当前值。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/3" src="https://codepen.io/rcfm/embed/abVQMMO?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/abVQMMO"> model/reactive/3</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="阻止创建未知-type-成员">阻止创建未知 type 成员</h3> <p>当创建成员时，如果成员的类型未注册，抛出异常。</p> <iframe height=600 style="width: 100%;" scrolling=no title="mode/reactive/4" src="https://codepen.io/rcfm/embed/vYWvRMg?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/vYWvRMg"> mode/reactive/4</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="阻止删除被依赖的成员">阻止删除被依赖的成员</h3> <p>当删除成员时候，如果该成员正在被引用，抛出异常。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/5" src="https://codepen.io/rcfm/embed/RwjEBaP?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/RwjEBaP"> model/reactive/5</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>以上这些由“必备钩子函数”产生的作用是 Reactive 正确处理成员状态变更的前提， 除此之外，我们还可以通过注入自定义的钩子函数，干预状态变更，以实现定制。 接下来，我们将详细介绍成员状态变更过程以及如何注入钩子函数。</p> <h2 id="成员状态变更过程">成员状态变更过程</h2> <p>由于关联关系的存在，当有成员被创建、销毁或更新时， 势必引起其它成员的状态变更，而这些状态的变更又可能引发新的变更。 为了高效处理这种连锁反应，<strong>Reactive 对成员状态的变更是批量的、异步的。 当产生状态变更时，所有关联成员的状态会按最优顺序在同一轮中变更，本轮引发的新变更将排队， 在下一轮中变更。</strong>具体过程如下图。</p> <figure class="media w-100" style="max-width: 601px"> <picture class=media-content style="padding-top: 266.3894%"> <img src="/assets/images/reactive_mutation-dbe9d62e.png" alt="状态变更流程图" width=1202 height=3202 /> </picture> </figure> <p>为了加深对状态变更异步性的理解，我们来看下面的示例。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/6" src="https://codepen.io/rcfm/embed/OJOdpXz?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/OJOdpXz"> model/reactive/6</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="钩子函数与状态变更">钩子函数与状态变更</h3> <p>在每一轮状态变更中，<strong>Job Runner 依 mutation 类型不同， 按照 <code>del</code>、<code>add</code>、<code>set</code>、<code>calc</code> 的顺序执行变更任务。</strong></p> <ul> <li><code>del</code>: 删除成员，产生该类型 mutation 的方法包括 <a href="/api/context/#delete"><code>reactive#delete()</code></a> 等。</li> <li><code>add</code>: 创建成员， 产生该类型 mutation 的方法包括 <a href="/api/context/#add"><code>reactive#add()</code></a>、 <a href="/api/reactive/#seed"><code>reactive#seed()</code></a> 等。</li> <li><code>set</code>: 更新属性设定值，产生该类型 mutation 的方法包括 <a href="/api/context/#set"><code>reactive#set()</code></a>、<a href="/api/reactive/#seed"><code>reactive#seed()</code></a> 等。</li> <li><code>calc</code>: 更新属性当前值，该类型 mutation 在每次完成 <code>set</code> mutation 后产生， 如果对该类型 mutation 的处理过程不做任何干预，默认会将属性的当前值及当前值错误信息指向其设定值及设定值错误信息， 也就是说默认情况下属性当前值及当前值错误信息与设定值及设定值错误信息相同。</li> </ul> <p>钩子函数可以从不同的节点注入，从而干预 mutation 的处理过程。 <strong>Job Runner 提供的钩子节点有四组： <code>before/after-del</code>、<code>before/after-add</code>、<code>before/after-set</code>，以及 <code>before/after-calc</code>。</strong> 下面我们来详细介绍。</p> <h4 id=beforeafter-del>before/after-del</h4> <p>当成员被删除前，注入到 <code>before-del</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object， <code>mutation.id</code> 为目标成员唯一标识。 如任一钩子函数返回值为 <code>false</code>，则针对目标成员的删除被终止。</p> <p>当成员被删除后，注入到 <code>after-del</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object， <code>mutation.id</code> 为已删除成员唯一标识，<code>mutation.parentId</code> 为其父成员唯一标识。</p> <iframe height=600 style="width: 100%;" scrolling=no title="mode/reactive/7" src="https://codepen.io/rcfm/embed/bGYOxEj?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/bGYOxEj"> mode/reactive/7</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h4 id=beforeafter-add>before/after-add</h4> <p>当成员被创建前，注入到 <code>before-add</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为待创建成员唯一标识， <code>mutation.parentId</code> 为待创建成员父级成员唯一标识， <strong><code>mutation.props</code> 为待创建成员属性设定值构成的 object，调用期间此 object 可被修改。</strong> 如任一钩子函数返回值为 <code>false</code>，则成员的创建被终止。</p> <p>当成员被创建后且属性设定值被赋值前，注入到 <code>after-add</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为该成员唯一标识， <code>mutation.parentId</code> 为该成员父级成员唯一标识， <code>mutation.props</code> 为该成员属性设定值构成的 object。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/8" src="https://codepen.io/rcfm/embed/bGYOxKz?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/bGYOxKz"> model/reactive/8</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h4 id=beforeafter-set>before/after-set</h4> <p>当成员属性设定值被赋值前，注入到 <code>before-set</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为目标成员唯一标识， <code>mutation.prop</code> 为目标成员待设定属性名，<strong><code>mutation.value</code> 为目标成员待设定属性值， 调用期间 <code>mutation.value</code> 可被修改。</strong> 如任一钩子函数返回值为 <code>false</code>，则成员属性设定值的赋值被终止。</p> <p>当成员属性设定值被赋值后且当前值被赋值前，注入到 <code>after-set</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为成员唯一标识， <code>mutation.prop</code> 为该成员被赋值的属性名，<code>mutation.value</code> 为该成员被赋值属性的设定值。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/9" src="https://codepen.io/rcfm/embed/eYexBQE?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/eYexBQE"> model/reactive/9</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h4 id=beforeafter-calc>before/after-calc</h4> <p>当成员属性当前值被赋值前，注入到 <code>before-calc</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为目标成员唯一标识， <code>mutation.prop</code> 为目标成员待更新属性名。 如任一钩子函数返回值为 <code>false</code>，则成员属性当前值的赋值被终止。</p> <p>当成员属性当前值被赋值后，注入到 <code>after-calc</code> 节点的钩子函数，按照注入顺序被调用， 传入一个 mutation object，<code>mutation.id</code> 为成员唯一标识， <code>mutation.prop</code> 为该成员基于默认逻辑赋值的属性名。 <strong>成员属性当前值及当前值错误的默认赋值逻辑为传址引用对应属性的设定值及设定值错误，调用期间可覆盖默认赋值逻辑。</strong></p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/10" src="https://codepen.io/rcfm/embed/XWzONyz?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/XWzONyz"> model/reactive/10</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>上面的几个示例比较简单地展示了各个节点钩子函数的作用和用法， 当与其它模型一起使用时，钩子函数可以完成复杂的功能， 下面我们来注册一个自定义类型的成员，并利用钩子函数来控制该类型成员的属性和行为。</p> <h2 id="注册成员类型">注册成员类型</h2> <p>在前文中我们提到过 Reactive 只接受创建已注册过类型的成员， 要注册一个新类型，可以使用 <a href="/api/reactive/#install"><code>reactive#install()</code></a> 方法， 该方法接收钩子函数的定义，且这些钩子函数只作用于匹配该类型的成员。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/11" src="https://codepen.io/rcfm/embed/oNomYQa?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/oNomYQa"> model/reactive/11</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>在上面的示例中，我们为新类型添加了 <code>label</code> 和 <code>value</code> 必须为字符串的校验逻辑， 但是这两个校验的大部分代码都是相同的，这样重复冗余的代码显然是不可接受的。在下面的示例中，我们进行了重构。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/12" src="https://codepen.io/rcfm/embed/vYWbyQP?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/vYWbyQP"> model/reactive/12</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>可以看到，在注册新类型时除了定义了 <code>hooks</code>，我们还定义了 <code>schema</code>， 并且在钩子函数中调用 <a href="/api/reactive/#schemafor"><code>reactive#schema.for()</code></a> 查询到了 <code>schema</code> 中 <code>label</code> 和 <code>value</code> 的 <code>dataType</code>， 这样一来，就可以动态地匹配到不同属性的校验逻辑，而不必编写重复的代码了。</p> <p>通过上例我们不难发现，<strong>钩子函数是控制成员属性和行为的具体实现， 而 <code>schema</code> 是对实现逻辑的一种高度抽象。</strong>没有具体实现做支撑的 <code>schema</code> 是起不到任何作用的。</p> <p>事实上，Reactive 提供了一些可复用的钩子函数， 上例中的校验逻辑我们并不需要自行编写，可直接使用 <code>ENABLE_SCHEMA_VALIDATION</code> 钩子函数配合 <code>schema</code> 定义实现， 我们在下面的示例中将逐一展示这些内置钩子函数的作用和用法。</p> <h3 id="校验属性值">校验属性值</h3> <p>Reactive 提供的 <code>ENABLE_SCHEMA_VALIDATION</code> 钩子函数提供了校验成员属性值的能力。</p> <p>如果在成员属性 <code>schema</code> 中定义了 <code>validation</code>，每当属性的当前值变更后，会按照 <code>validation</code> 规则对该值进行校验，成员的错误信息将根据校验结果被赋值为 <code>null</code> 或一个包含 <code>VALIDATOR_VALIDATION_FAILED</code> 类型错误的数组。</p> <p>如果在成员属性 <code>schema</code> 中定义了 <code>rawValidation</code>，每当属性的设定值变更后，会按照 <code>rawValidation</code> 规则对该值进行校验，成员的错误信息将根据校验结果被赋值为 <code>null</code> 或一个包含 <code>VALIDATOR_VALIDATION_FAILED_RAW</code> 类型错误的数组。</p> <p>校验规则可以被定义为 <code>null</code>，或一个数组，数组中可包含受支持的 DSL 校验表达式，或返回错误信息的函数。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/13" src="https://codepen.io/rcfm/embed/mdqvOQY?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/mdqvOQY"> model/reactive/13</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="冻结设定值">冻结设定值</h3> <p>Reactive 提供的 <code>ENABLE_SCHEMA_ALWAYS</code> 钩子函数提供了冻结成员属性设定值的能力。 如果在成员属性 <code>schema</code> 中定义了 <code>always</code>，成员属性的设定值将始终等于 <code>always</code> 的值 。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/14" src="https://codepen.io/rcfm/embed/WNXPoLw?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/WNXPoLw"> model/reactive/14</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="使用默认设定值">使用默认设定值</h3> <p>Reactive 提供的 <code>ENABLE_SCHEMA_DEFAULT</code> 钩子函数提供了使用默认属性设定值的能力。 如果在成员属性 <code>schema</code> 中定义了 <code>default</code>，那么在创建成员时，如果成员属性设定值未定义， 则使用 <code>default</code> 相同的值来作为其设定值。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/15" src="https://codepen.io/rcfm/embed/podGNqR?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/podGNqR"> model/reactive/15</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <h3 id="阻止添加到不合规父级">阻止添加到不合规父级</h3> <p>Reactive 提供的 <code>BLOCK_INVALID_PARENT</code> 钩子函数提供了限制父级成员类型的能力， 子成员只能添加到特定类型范围内的父级成员。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/16" src="https://codepen.io/rcfm/embed/rNYPwYZ?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/rNYPwYZ"> model/reactive/16</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>到目前为止，我们已经接触到两种注入钩子函数的方式，在调用 <a href="/api/reactive/#install"><code>reactive#install()</code></a> 时注入， 和直接使用 <a href="/api/reactive/#hooksmount"><code>reactive#hooks.mount()</code></a> 注入。通常情况下，建议使用后者注入全局钩子函数， 使用前者注入针对特定成员类型的钩子函数。 当然，<a href="/api/reactive/#hooksmount"><code>reactive#hooks#mount()</code></a> 本身也支持向特定类型注入钩子函数， 只是过多的使用可能导致钩子函数的管理混乱，不建议过度使用。</p> <h2 id=dsl>DSL</h2> <p>在前文中，我们提过 Reactive 的 DSL 语句， 简单地说，<strong>DSL 是针对特定领域、高度抽象的专用语言</strong>，比如 SQL 就是针对数据库设计的语言， 专用于高效地编写数据库读写逻辑，但不能像通用型编程语言那样构建种类繁多的应用。 <strong>Reacitve DSL 是专为表单领域设计的，用来描述表单模型的语言。</strong> 基于标准的 js plain object，语句构成和使用方式简单易懂，我们来看下面的例子。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/17" src="https://codepen.io/rcfm/embed/eYexRqx?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/eYexRqx"> model/reactive/17</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>通过上面的例子可以很直观地看到，<strong>Reactive DSL 语言构件由四部分构成：条件语句、校验表达式、计算表达式以及引用插值符。</strong> 我们在介绍“必备钩子函数”时提到过，DSL 的解析过程借助了钩子函数来实现， 但本质上， Reactive DSL 语言构件的能力是由不同的模型做支撑的，我们可以通过扩展这些模型，实现 DSL 能力和语意范围的扩充。 下面我们将一起实践，扩展 Reactive DSL。</p> <h3 id="解析插值符">解析插值符</h3> <p>Reactive DSL 引用插值符 <code>&lt;&lt; &gt;&gt;</code> 的解析过程是，将插值符内的路径以 <code>.</code> 号分割， 最后一位是被引用的属性名，前几位是被引用成员的 <code>name</code>， 按照 <code>name</code> 查找成员并使用 <a href="/api/context.dependency/">Dependency</a> 模型维护引用者和被引用者的依赖关系。 如果被引用的成员在查找过程中不存在，则会停止查找，并向引用者的存储空间写入错误信息， 如果引用者和被引用者产生循环引用，则不会添加依赖关系，并向引用者的存储空间写入错误信息。</p> <p>举例来说，<code>&lt;&lt; parentName.childName.childProp &gt;&gt;</code> 的解析过程是， 从根成员的子级开始，依次向下查找 <code>name</code> 为 <code>parentName</code> 的成员， 和 <code>name</code> 为 <code>childName</code> 的成员，并添加两个成员的 <code>name</code> 属性和引用者间的依赖关系， 以及 <code>name</code> 为 <code>childName</code> 的成员的 <code>childProp</code> 属性和引用者间的依赖关系。</p> <p>在解析过程中，成员的查找方式可以针对成员类型的不同进行修改， 基本原理是当查找到某个成员时，对其后代成员的查找过程进行拦截并返回修改后的查找结果。 下例中，我们注册了一个自定义成员类型，并将查找其子成员的方式由默认的按 <code>name</code> 查找， 修改为按照数组下标进行查找。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/18" src="https://codepen.io/rcfm/embed/JjOzzzz?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/JjOzzzz"> model/reactive/18</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p>需要注意的是， <strong>如果需要修改成员的查找方式，那么 <code>schema.reference.parse</code> 和 <code>schema.reference.stringify</code> 大多需要同步定义。</strong> 因为与 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 类似，这两个方法互为镜像，一个方法的输入是另一个方法的输出， 如果不同步定义，可能导致成员属性引用路径的拆分逻辑和拼接逻辑不匹配。</p> <h3 id="注册校验方法">注册校验方法</h3> <p>Reactive DSL 中的校验表达式是基于 <a href="/api/validator/">Validator</a> 模型的能力实现解析的， 扩展 <code>reactive#validator</code> 中的校验方法，将同步扩展 DSL 校验表达式的语义范围。 我们来看下面的示例。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/19" src="https://codepen.io/rcfm/embed/Rwjmbwp?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/Rwjmbwp"> model/reactive/19</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p><strong>在 Reactive DSL 解析过程中，当校验表达式合规且定义的校验方法没有返回错误消息时， 表达式求值为 <code>true</code>，反之为 <code>false</code>。</strong>所以，任何被注册的校验方法都可以在 DSL 中充当布尔运算的条件， 从而实现了 DSL 语意范围的扩充。</p> <p>另外需要提及的是，校验方法注册后，前文提到的 <code>ENABLE_SCHEMA_VALIDATION</code> 钩子函数支持的 <code>validation</code> 及 <code>rawValidation</code> 可应用的表达式范围也会被同步扩充。</p> <p>为了方便使用，Reactive 在实例化过程中内置了一部分校验方法，可以直接使用。</p> <ul> <li><code>dataType</code>，校验数据类型是否合规，如 <code>{dataType: ['String', 'Number']}</code>。</li> <li><code>equalTo</code>，校验数据是否等于某值，支持对象和数组，如 <code>{equalTo: [1, {val: 2}]}</code>。</li> <li><code>isInteger</code>，校验数据是否是整数，如 <code>{isInteger: true}</code>。</li> <li><code>maxLength</code>，校验字符串和数组最大长度，如 <code>{maxLength: 10}</code>。</li> <li><code>presence</code>，校验数据是否为空，如 <code>{presence: true}</code>。</li> <li><code>withFormat</code>，校验字符串是否满足格式，如 <code>{withFormat: '/^abc$/'}</code>。</li> </ul> <h3 id="注册计算方法">注册计算方法</h3> <p>Reactive DSL 中的计算表达式是基于 <a href="/api/calculator/">Calculator</a> 模型的能力实现解析的， 扩展 <code>reactive#calculator</code> 中的计算方法，将同步扩展 DSL 计算表达式的语义范围。请看下面的示例。</p> <iframe height=600 style="width: 100%;" scrolling=no title="model/reactive/20" src="https://codepen.io/rcfm/embed/XWzwrYX?default-tab=js%2Cresult&amp;editable=true" frameborder=no loading=lazy allowtransparency=true allowfullscreen=true> See the Pen <a href="https://codepen.io/rcfm/pen/XWzwrYX"> model/reactive/20</a> by rcfm (<a href="https://codepen.io/rcfm">@rcfm</a>) on <a href="https://codepen.io">CodePen</a>. </iframe> <p><strong>在 Reactive DSL 解析过程中，当计算表达式合规时，求值结果为定义的计算方法的返回值，否则为 <code>null</code>。</strong> 成员的属性值可以直接被设定为计算表达式，也可以嵌套进条件语句进行设定，所以，注册计算表达式也可以实现 DSL 语意范围的扩充。</p> <p>为了方便使用，Reactive 在实例化过程中内置了一部分计算方法，可以直接使用。</p> <ul> <li><code>add</code>，数字加法，如 <code>{add: [1, 2, 3]}</code>。</li> <li><code>devide</code>，数字除法，如 <code>{devide: [8, 2, 2]}</code>。</li> <li><code>map</code>，映射任意类型数据，如 <code>{map: {val: true}}</code>。</li> <li><code>minus</code>，数字减法，如 <code>{minus: [10, 1]}</code>。</li> <li><code>multiple</code>，数字乘法，如 <code>{multiple: [4, 5, 6]}</code>。</li> </ul> <h2 id="小结">小结</h2> <ul> <li>Reactive 是一个可被扩展的引擎核心。</li> <li>Reactive 实例是组合了其它模型的 <a href="/api/context/">Context</a> 实例。</li> <li>成员状态包括属性设定值、属性当前值，以及错误信息。</li> <li>属性的设定值和当前值在无成员间关联时是相同的，但在有成员间关联时是不同的。</li> <li>成员的 <code>type</code> 是区分成员类型的标识，被设定后，不接受更新，且不接受被设定为 DSL。</li> <li>成员的 <code>name</code> 在 DSL 插值符引用路径中是同辈成员间的唯一性标识，不接受被设定为 DSL。</li> <li>Reactive 对成员状态的变更是批量的、异步的。</li> <li>Job Runner 依 mutation 类型不同，按照 <code>del</code>、<code>add</code>、<code>set</code>、<code>calc</code> 的顺序执行变更任务。</li> <li>Job Runner 提供的钩子节点有四组：<code>before/after-del</code>、<code>before/after-add</code>、<code>before/after-set</code>，以及 <code>before/after-calc</code>。</li> <li>钩子函数是控制成员属性和行为的具体实现，而 <code>schema</code> 是对实现逻辑的一种高度抽象。</li> <li>Reacitve DSL 是专为表单领域设计的，用来描述表单模型的语言。</li> <li>Reactive DSL 语言构件由四部分构成：条件语句、校验表达式、计算表达式以及引用插值符。</li> <li>如果需要修改成员的查找方式，那么 <code>schema.reference.parse</code> 和 <code>schema.reference.stringify</code> 大多需要同步定义。</li> <li>在 Reactive DSL 解析过程中，当校验表达式合规且定义的校验方法没有返回错误消息时，表达式求值为 <code>true</code>，反之为 <code>false</code></li> <li>在 Reactive DSL 解析过程中，当计算表达式合规时，求值结果为定义的计算方法的返回值，否则为 <code>null</code>。</li> </ul> <p>通过阅读本章内容，我们较深入地了解了 Reactive 的核心实现原理， 关于 Reactive 的更多内容，请阅读 <a href="/api/reactive/">Reactive 接口文档</a>。 在下一章，我们将一起使用 Reactive 从头 <a href="/guide/model/form_construction/">构建一个 Form 引擎</a>， 将本章的原理应用到实践中。</p> </article> <footer class="footer py-medium px-medium py-large-m sd-low"> <p class="p7 ta-center c-secondary"> Reactive Form 基于 <a href="https://creativecommons.org/licenses/by-nd/3.0/cn/legalcode">CC BY-ND</a> 协议发布 </br> Copyright © 2022 吉林省吉林祥云信息技术有限公司 </p> </footer> </div> </div> </body> </html>